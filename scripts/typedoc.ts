import * as TypeDoc from 'typedoc';
import { writeFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { format } from 'prettier';
import options from '../.prettierrc.cjs';
import faker from '../src';

const pathRoot = resolve(__dirname, '..');
const pathOutputDir = resolve(pathRoot, 'docs', 'api');
const pathOutputJson = resolve(pathOutputDir, 'typedoc.json');

async function build() {
  const app = new TypeDoc.Application();

  app.options.addReader(new TypeDoc.TSConfigReader());
  // If you want TypeDoc to load typedoc.json files
  //app.options.addReader(new TypeDoc.TypeDocReader());

  app.bootstrap({
    entryPoints: ['src/index.ts'],
    pretty: true,
    cleanOutputDir: true,
  });

  const project = app.convert();

  if (!project) {
    // Project may not have converted correctly
    return;
  }
  // Useful for analyzing the content
  await app.generateJson(project, pathOutputJson);

  const modules = project
    .getChildrenByKind(TypeDoc.ReflectionKind.Namespace)[0]
    .getChildrenByKind(TypeDoc.ReflectionKind.Class);

  // Generate module file
  for (const module of modules) {
    const moduleName = module.name.replace('_', '');
    const lowerModuleName =
      moduleName.substring(0, 1).toLowerCase() + moduleName.substring(1);
    console.log(`Processing Module ${moduleName}`);
    let content = `# ${moduleName}

    <!-- This file is automatically generated. -->
    <!-- Run 'pnpm run typedoc' to update -->

    [[toc]]

    ::: v-pre

    `.replace(/\n +/g, '\n');

    if (module.comment?.shortText) {
      content += module.comment?.shortText + '\n\n';
    }
    if (module.comment?.text) {
      content += module.comment.text + '\n\n';
    }

    const methods = module.getChildrenByKind(TypeDoc.ReflectionKind.Method);

    // Generate method section
    for (let method of methods) {
      const methodName = method.name;
      const prettyMethodName =
        methodName.substring(0, 1).toUpperCase() +
        methodName.substring(1).replace(/([A-Z]+)/g, ' $1');
      console.log(`- method ${prettyMethodName}`);
      const signature = method.signatures[0];
      let methodShortText = signature.comment?.shortText;
      if (!methodShortText) {
        methodShortText = 'Missing';
      }
      content += `## ${prettyMethodName}\n\n${methodShortText}\n\n`;
      if (signature.comment?.text) {
        content += signature.comment.text + '\n\n';
      }

      // Generate parameter section
      const typeParameters = signature.typeParameters || [];
      const parameters = signature.parameters || [];
      const signatureTypeParameters: string[] = [];
      const signatureParameters: string[] = [];
      let requiresArgs = false;
      if (typeParameters.length !== 0 || parameters.length !== 0) {
        content += `**Parameters**\n\n`;

        // typeParameters
        typeParameters.forEach((parameter, index) => {
          const parameterName = parameter.name;

          signatureTypeParameters.push(parameterName);
          content += `- \\<${parameterName}\\> - ${
            parameter.comment?.shortText || 'N/A'
          }\n`;
          if (parameter.comment?.text) {
            content += '  ' + parameter.comment.text.replace('\n', '\n  ');
          }
        });

        // parameters
        parameters.forEach((parameter, index) => {
          const parameterDefault = parameter.defaultValue;
          const parameterRequired = typeof parameterDefault === 'undefined';
          if (index == 0) {
            requiresArgs = parameterRequired;
          }
          const parameterName = parameter.name + (parameterRequired ? '?' : '');
          const parameterType = parameter.type.toString();
          let shortText = parameter.comment?.shortText?.trim();
          if (!shortText) {
            shortText = 'N/A';
          }
          let parameterDefaultText = '';
          let parameterDefaultSignatureText = '';
          if (!parameterRequired) {
            parameterDefaultText = ' = `' + parameterDefault + '`';
            parameterDefaultSignatureText = ' = ' + parameterDefault;
          }

          signatureParameters.push(
            parameterName + ': ' + parameterType + parameterDefaultSignatureText
          );
          content += `- ${parameterName}: ${parameterType}${parameterDefaultText} - ${shortText}\n`;
          if (parameter.comment?.text) {
            content += '  ' + parameter.comment.text.replace('\n', '\n  ');
          }
        });
        content += '\n\n';
      }
      content += '**Returns:** ' + signature.type.toString() + '\n\n';

      // Generate usage section

      content += '````ts\n';

      let signatureTypeParametersString = signatureTypeParameters.join(', ');
      if (signatureTypeParametersString.length !== 0) {
        signatureTypeParametersString = `<${signatureTypeParametersString}>`;
      }
      const signatureParametersString = signatureParameters.join(', ');

      content += `faker.${lowerModuleName}.${methodName}${signatureTypeParametersString}(${signatureParametersString}): ${signature.type.toString()}\n`;
      faker.seed(0);
      if (!requiresArgs) {
        try {
          let example = JSON.stringify(faker[lowerModuleName][methodName]());
          if (example.length > 50) {
            example = example.substring(0, 47) + '...';
          }
          // Avoid updating the time.md all the time
          if (lowerModuleName === 'time' && methodName === 'recent') {
            example = '1643067304379';
          }

          content += `faker.${lowerModuleName}.${methodName}()`;
          content += (example ? ' // => ' + example : '') + '\n';
        } catch {
          console.log(
            `Failed to call: faker.${lowerModuleName}${methodName}()`
          );
        }
      }

      content += '````\n\n';
    }

    // Format md

    content = format(content, {
      ...options,
      parser: 'markdown',
    });

    // Write to disk

    writeFileSync(resolve(pathOutputDir, lowerModuleName + '.md'), content);
    console.log(`Done Module ${moduleName}`);
  }
}

build().catch(console.error);
